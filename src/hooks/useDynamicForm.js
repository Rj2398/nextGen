import { useState, useMemo } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Alert } from 'react-native';
// NOTE: The 'qs' library is NOT imported, as requested. We use the native URLSearchParams API.

// --- ðŸŒŸ ACTUAL API IMPORT ðŸŒŸ ---
import { api } from '../utils/api'; 

/**
 * The actual API call function responsible for submitting the URL-encoded payload.
 * It explicitly sets the 'Content-Type' header required by the backend.
 * * @param {object} params - Contains the payload string and the endpoint.
 * @returns {Promise<any>} The response data from the API.
 */
const submitDynamicForm = async ({ payload, endpoint }) => {
    
    // Log the planned API action before sending the request.
    console.log("--- Sending Real API Call from Hook (Logcat) ---");
    console.log("Method: POST");
    console.log("Relative Endpoint:", endpoint); 
    // This log shows the desired URL-encoded string payload.
    console.log("Payload (URL-Encoded String):", payload); 
    console.log("-----------------------------------------------");

    try {
        // --- ðŸŒŸ ACTUAL AXIOS CALL ðŸŒŸ ---
        // Pass the string payload and explicitly set the correct Content-Type.
        const response = await api.post(endpoint, payload, {
            headers: {
    
                // This matches the string payload generated by params.toString()
                'Content-Type': 'multipart/form-data', 
            }
        });
        
        console.log("API Success Response:", response.data);
        return response.data;
        
    } catch (error) {
        console.error("API Call Failed:", error);
        throw error;
    }
};

/**
 * ðŸŽ£ A globally reusable hook for managing form state and handling dynamic API submission.
 * * @param {object} formSchema - The dynamic form structure (can have a top-level 'data.pages' or just 'pages').
 * @param {object} initialBaseData - Optional base data to pre-populate form fields.
 */
export default function useDynamicForm(formSchema, initialBaseData = {}) {
    
    // 1. --- ðŸŒŸ FIELD LOCATION MAP (CRITICAL FOR NEW PAYLOAD FORMAT) ðŸŒŸ ---
    // Maps fieldName or buttonId to its full hierarchical path: PageName.SectionName
    const fieldLocationMap = useMemo(() => {
        const map = {};
        
        // Handle the case where the schema is wrapped in a 'data' property from the API response
        const pages = formSchema?.data?.pages || formSchema?.pages; 

        if (!pages || pages.length === 0) {
            console.error("ERROR: Pages structure not found in formSchema.");
            return map;
        }
        
        pages.forEach(page => {
            const pageName = page.pageName;
            if (!pageName) return;

            page.sections.forEach(section => {
                const sectionName = section.name;
                if (!sectionName) return;

                // 1. Map FIELDS
                (section.fields || []).forEach(field => {
                    if (field.fieldName) {
                        map[field.fieldName] = { 
                            pageName: pageName, 
                            sectionName: sectionName 
                        };
                    }
                });
                
                // 2. Map BUTTONS (for the action_button key)
                (section.buttons || []).forEach(button => {
                    if (button.buttonId) {
                         // The action button ID is included in combinedData under the key 'action_button'
                         // but we map it here by its actual ID (e.g., 'btn_create_deal')
                         map[button.buttonId] = { 
                            pageName: pageName, 
                            sectionName: sectionName 
                        };
                    }
                });
            });
        });
        
        // Log the generated map for debugging purposes
        console.log("Generated Field Location Map:", map);
        
        return map;
    }, [formSchema]);

    // 2. Initialize form state based on dynamic schema fields
    const initialState = useMemo(() => {
        // Use the same robust way to access pages as in fieldLocationMap
        const pages = formSchema?.data?.pages || formSchema?.pages;
        
        const allFields = pages 
            ? pages.flatMap(page => 
                page.sections.flatMap(section => section.fields)
              )
            : []; 

        return allFields.reduce((acc, field) => {
            acc[field.fieldName] = initialBaseData[field.fieldName] !== undefined
                ? initialBaseData[field.fieldName]
                : (field.fieldType === 'MultiSelect' 
                    ? (field.defaultValue || []) 
                    // Ensure all other values are initialized as string for consistency, 
                    // or empty string if default is null/undefined.
                    : (field.defaultValue !== null && field.defaultValue !== undefined ? String(field.defaultValue) : ''));
            return acc;
        }, {});
    }, [formSchema, initialBaseData]);

    const [formData, setFormData] = useState(initialState);
    
    /**
     * Reusable handler for updating a form field value.
     */
    const handleChange = (fieldName, value) => {
        setFormData(prev => ({ ...prev, [fieldName]: value }));
    };

    // 3. API Submission Mutation (using React Query)
    const queryClient = useQueryClient(); 

    const { mutateAsync: submitMutation, isLoading: isSubmitting } = useMutation({
        mutationFn: submitDynamicForm, 
        onError: (error) => {
            // Display user-friendly error message
            Alert.alert("Error", error.message || 'Submission failed. Please try again.');
        },
        // Optionally add onSuccess to invalidate relevant queries
        // onSuccess: () => {
        //     queryClient.invalidateQueries({ queryKey: ['someFormList'] });
        // }
    });

    /**
     * Logic for transforming and submitting form data into the URL-encoded string format.
     */
    const handleFormSubmission = async (action, { externalBaseData, onSuccessNavigation }) => {
        // Guard clause to ensure the action is a valid POST API call
        if (!action || !action.apiCallRequired || action.method !== 'POST' || !action.endpoint) return;

        try {
            // Combine external base data, local form data, and the action button ID
            const combinedData = {
                ...externalBaseData,
                ...formData, 
                // Add the specific button ID which triggered the submission
                action_button: action.buttonId
            };
            
            const params = new URLSearchParams();
            
            console.log("1. Combined Data (Before Filtering/Mapping):", combinedData);
            
            // Build the URL-encoded string by mapping keys to the Page.Section.Field format
            for (const key in combinedData) {
                if (Object.hasOwnProperty.call(combinedData, key)) {

                    // Look up the location based on the field name or 'action_button' key
                    const location = key === 'action_button' 
                        ? fieldLocationMap[combinedData[key]] // Lookup the button's location by its actual ID
                        : fieldLocationMap[key];
                    
                    // CRITICAL CHECK: Skip if location mapping is missing (i.e., field not in schema pages/sections)
                    if (!location) {
                         // This log confirms the skipping issue found during debugging
                         console.warn(`2. WARNING: SKIPPING key (No Location Map): ${key}. Value: ${combinedData[key]}`);
                         continue; 
                    } 
                    
                    let value = combinedData[key];
                    
                    // a) Handle Arrays (e.g., MultiSelect) -> convert array to comma-separated string
                    if (Array.isArray(value)) {
                        value = value.join(',');
                    }

                    // b) Handle Booleans -> convert to string 'true'/'false'
                    if (typeof value === 'boolean') {
                        value = value ? 'true' : 'false';
                    }

                    // c) Append to URLSearchParams if value is meaningful (excluding null/undefined/empty string)
                    if (value !== null && value !== undefined && String(value).length > 0) {
                        
                        // Construct the required key: PageName.SectionName.fieldName (or .action_button)
                        // If the key is 'action_button', the final key will be Page.Section.action_button
                        const finalKey = `${location.pageName}.${location.sectionName}.${key}`;
                        
                        // This log shows the final key/value pair being added
                        console.log(`3. Final Key/Value Pair Added: ${finalKey} = ${String(value)}`);
                        
                        // Append the key/value pair. URLSearchParams handles URL encoding.
                        params.append(finalKey, String(value)); 
                    }
                }
            }
            
            // Convert URLSearchParams object to the final URL-encoded string
            const payload = params.toString(); 

            // Call the mutation with the endpoint and the URL-encoded string payload.
            const result = await submitMutation({
                payload: payload, // ðŸ‘ˆ Send the URL-ENCODED STRING
                endpoint: action.endpoint
            });

            // Show success alert to the user
            Alert.alert("Success", result.message || `${action.label} successful.`);
            
            // Execute post-success navigation logic
            if (onSuccessNavigation) {
                onSuccessNavigation(combinedData); 
            }

        } catch (error) {
            // Error handling is managed by useMutation's onError, but this ensures any pre-mutation error is caught
            console.error("Form Submission Error in Hook (Final Catch):", error);
            // Re-throw the error to ensure consuming component can handle it if needed
            throw error; 
        }
    };
    
    // Return the reusable interface
    return {
        formData,
        handleChange,
        handleFormSubmission,
        isSubmitting
    };
}